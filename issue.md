#*生活

###糖尿病和风湿患者应该遵循以下饮食建议：

可以吃的东西：

1. 高纤维食物：如全麦面包、燕麦、豆类、水果和蔬菜等，这些食物有助于降低血糖、降低胆固醇和维持肠道健康。

2. 水果和蔬菜：因为它们富含维生素和矿物质，是健康的饮食中必不可少的一部分。

3. 高蛋白质食物：如鱼、鸡肉、瘦肉、鸡蛋、豆类等，这些食物有助于稳定血糖水平、降低风湿痛和修复肌肉。

不可以吃的东西：

1. 高糖食品：如甜点、糖果和饮料等，这些食品会导致血糖升高。

2. 饱和脂肪酸和反式脂肪酸：如薯条、炸鸡、肉类、油炸食品等，这些食品可能会加重炎症或造成内分泌失调。

3. 盐：过多的盐会导致水潴留和加重关节疼痛。

总的来说，糖尿病和风湿患者应该坚持低糖、低脂肪、低盐和高纤维饮食，并注意控制饮食量。此外，患者还应根据医生的建议进行特殊的饮食调整。



###痛风和高尿酸患者应该选择低嘌呤食物，减少高嘌呤食物的摄入。以下是一些可食用和不可食用的食物：

可食用的食物：水果、蔬菜、全谷物类食物、水产品、豆类、低脂肪乳制品和鸡蛋等。

少量食用的食物：禽肉、瘦肉、杏仁、核桃和葡萄。

不可食用的食物：高嘌呤食物包括肝、肾、红肉、肉汤、海鲜、鱼籽、菇类和豌豆等。

此外，高尿酸患者也应该增加水的摄入，以增加尿酸的排泄，少饮酒，限制含糖饮料和甜食的摄入。建议患者咨询专业医生或营养师的建议并制定个人化的饮食计划。





###健康的一日三餐搭配建议如下：

早餐：
1. 吃鸡蛋：可以吃煮鸡蛋、荷包蛋、煎蛋等，可以搭配全麦面包、蔬菜沙拉等。
2. 吃燕麦片：可以用牛奶、酸奶、蜂蜜等配料搭配，也可以加入水果切片或果干。

午餐：
1. 吃鱼肉或禽肉：可以选择烤鱼、烤鸡等，可以搭配少量的土豆、胡萝卜、蔬菜沙拉等。
2. 吃杂粮主食：可以选择糙米饭、玉米面饼等，可以搭配蔬菜汤或番茄鸡蛋汤等清淡汤品。

晚餐：
1. 吃豆腐：可以选择清炒豆腐、豆腐汤、麻婆豆腐等，可以搭配一定数量的杂粮主食、蔬菜或绿色水果。
2. 吃粥类：可以选择小米粥、绿豆粥、玉米粥等，可以搭配少量的豆腐丝、菜丝、燕麦、馒头等。

以上仅为建议，实际的饮食搭配还需根据个人健康状况以及身体需要来酌情调整。此外，建议饮食要多样化，合理搭配，适量摄入，注重营养均衡。



###减重的关键是控制饮食和增加运动量。以下是一些可能有帮助的建议：

1. 控制饮食：控制饮食是减重的主要因素之一。限制高热量和高脂肪食物的摄入，并增加蛋白质、蔬菜和水果的摄入。

2. 增加运动量：增加运动量可以加快代谢和消耗更多的卡路里。可以选择有氧运动，如快走、慢跑、游泳等。每周至少150分钟的有氧运动。

3. 控制饮食：减少糖、淀粉和高热量的食物摄入，如甜点、薯条、糖果等。

4. 增加蛋白质摄入：增加蛋白质的摄入可以帮助增加饱腹感，减少摄入的卡路里。

5. 减少碳酸饮料和果汁的摄入：这些饮料中含有大量的糖分和卡路里，会增加体重。

6. 每天进行一些简单的体育活动：例如，爬楼梯、散步、打球等，可以帮助燃烧卡路里。

重要的是要记住，健康和安全是减重的关键。不要过度饥饿或过度锻炼，这可能会伤害你的身体。如果您对如何减重有疑虑，请咨询专业人士或医生。



# *高效学习

1.思维导图做读书笔记

 读书时，试着用思维导图做梳理，你会发现读完了可以很方便地回顾，以后时长翻翻自己的思维导图笔记，再也不用发愁读过的书会忘记了，而且脑子中往往会结构性地出现整本书的模型，非常有用。

2.横向读书法

   当你了解一个有立场的学科或者主题时，不妨几个立场的书一起读，可以有效帮助你辨别更全面的事实，尤其是历史、宗教、哲学等。

3.纵向读书法

   想快速了解一个学科，最好的办法就是迅速大量阅读同学科的书，不求甚解，多读几本你就懂了，因为精华的部分会重复出现的。

4.主动分享

​    想真正掌握所学，就要不吝分享，分享是把所学化为所用最快的方法

5.学会做计划

​    凡事预则立，学会做年度大事件计划，月度计划，周计划，最好每天早上也做个晨间计划，1分钟搞定高效率的一整天。其他事情也是如是，不要迷茫，按照计划走，才有方向感。

6.学会做总结

   每天晚上给自己一个独处的时间，思考自己的言行，得与失，最好做个记录，比如日记。完成一个大的项目或者事件时学会做总结，为下一次同样的事情打基础。

7.利用碎片时间

   学会利用碎片时间，集腋成裘，比如阅读、思考，甚至休息。

8.常用的东西要舒服

​    常用的鼠标、键盘、手机、包等，这方面不要吝啬，甚至要学会适当奢侈，选择最舒适的，工欲善其事，必先利其器。（不要轻易选择、决定，量力而为，**严进宽出**，贵的也不一定好，实事求是根据自身情况做选择）

9.学会放松

​    会娱乐会放松，才能更快乐地活着，所以学会主动放松，投入地放松。

10.冥想

​     冥想是非常值得学习的技巧，可以再冥想中仔细观察自己，体会自己，彻底放松自己，了解自己。

11.把锻炼和兴趣联合起来

​     比如跑步是一件很痛苦的事，我就在跑步的时候听评书，一下就觉得跑步得痛苦好像消失了，听书的乐趣让我慢慢坚持了下来。



12.可以先试着这些简单的tips

（1）早睡早起；

（2）坚持在同样的时间睡觉和起床；

（3）少食多餐(正餐不要吃太多，正餐之间吃一些低糖低热零食)；

（4）饮食健康，营养均衡；

（5）减少单糖化合物摄入；

（6）每天吃早餐；

（7）每天喝1.4~1.8L水；

（8）每天进行适量身体活动；

（9）工作每90min休息片刻（根据情况做调整）



###Peanuts:

1. 深入学习 HTML、CSS、JavaScript
2. 掌握 React 或 Vue 等主流框架，并深入学习相关生态工具如 Redux、Webpack、Babel 等
3. 学习现代化的前端工程化和自动化构建工具，如 Gulp、Grunt、Webpack、Rollup 等
4. 学习前端性能优化相关知识，如代码压缩、图片优化、懒加载等
5. 熟练使用至少一种 CSS 预处理器如 Sass、Less 等
6. 学习前端框架的底层原理，如 Virtual DOM、数据绑定、事件机制等
7. 学习开发 SPA（单页应用）和 PWA（渐进式 Web App）
8. 学习前端安全相关知识如 XSS、CSRF、CSP 等
9. 学习函数式编程和 React Hooks 等新特性，提高代码质量和可读性
10. 学习 Node.js、Express、MongoDB 和其他后端技术，能够开发全栈应用。

###Peanuts:
作为一名AI助手，我会向您介绍一条前端学习路线。前端开发是一门不断发展和进化的艺术。下面是一些建议的技能和工具，可以帮助您成为一名成功的前端开发人员。

第一步：HTML、CSS和JavaScript基础

- HTML（超文本标记语言）: ：用于创建网页结构和内容（例如段落、标题、图像等）。
- CSS（层叠样式表）: 用于定义网页的样式和布局（例如颜色、字体、位置等）。
- JavaScript: 用于实现网页的动态交互（例如，当用户点击一个按钮时，实现某些操作或验证表单）。

第二步：学会使用一种JavaScript框架

- Angular：由Google开发，已成为最受欢迎的前端框架之一，使开发更快、更简单，特别是在大型应用程序中。
- React：由Facebook开发，是一个非常流行的框架，尤其适合构建单页面应用程序。
- Vue：一个渐进式JavaScript框架，易于学习和使用，并且在构建用户界面方面非常灵活和高效。

第三步：学习使用前端工具

- Webpack: 用于配置并打包前端项目的模块，最终将它们转换为浏览器可以理解的JavaScript、CSS或HTML文件。
- jQuery: 一个JavaScript库，它使DOM操作变得更易于使用，以及实现动态效果和Ajax请求。
- Bootstrap: 一个流行的框架用于构建移动设备友好和响应式的网站，提供了一些CSS、HTML和JavaScript组件。

第四步：学习构建web组件和应用程序

- Web组件: 它们是一种可重用的自定义元素，提供了一种可维护和组装的方式，用于构建大规模的web应用程序。
- Progressive Web App（PWA）：一个类型的Web应用程序，可以提供类似于本地应用程序的用户体验和功能，如离线访问和推送通知。

综上所述，以上路线是基础和进阶路线的示例，让您迈出前端开发职业道路的第一步。



# *冥想

- 冥想时很容易就忘了时间，但过于关注时间只会分散你的注意力。有些人认为设定闹钟有助于解决这一问题，但记得要选择铃声轻柔一些的闹钟。如果闹钟声音太突兀，总是挂念闹钟什么时候响起的想法也会干扰你。
- 在平常不冥想的时候要有意识地关注自己的情绪和想法。你会发现，在进行了冥想的日子里，你会比在没有冥想的日子里更平静、更愉悦、更清醒。
- 不要让内心的声音偷偷混进你的思绪。你可以留心这些想法，但别被它们牵着鼻子走。
- 如果你想进行冥想，却感到精疲力竭、浑身酸痛、身体不适，或者只是单纯无法达到某一程度的放松，那么先做些放松身心的活动吧。你可以先散步、跑步、淋浴或泡澡，这些活动都能有效纾解压力。之后，再试着开始冥想。
- 正确的姿势能为你的肺部腾出更多空间，使你的呼吸更顺畅。实际上，你会感受到臀部到颈部的大部分肌肉都在在以隔膜的呼吸肌为中心发挥作用。尽管只有一点点，但你能感受到它们都在协助隔膜的呼吸。如果你留意到了这一点，那么说明你的姿势是正确的。正确的姿势不难维持且十分舒适，你会有一种漂浮在水面上的感觉。
- 在彻底平静之时，你想要做什么都可以。有些人发现这种时候特别适宜于思考重大决策或探究自己潜意识中的想法，另一些人则单纯十分享受冥想带来的这种难得的“休息”。对于有宗教信仰的人来说，冥想则是一种与他们的神（们）沟通并获得神启的方式。
- 在冥想者学会彻底的专注或宁神之前，冥想就已经发挥了它的作用。光是通过练习，冥想就能给你带来好处。
- 选择最适合你的方式。适合别人的方式并不一定就适合你，别轻易放弃。记住，要放松！
- 欲速则不达。冥想并不能让你在一夜之间变成得道大师，只有不抱功利心地进行纯粹的冥想，才能获得最好的效果。
- 一些不为人所注意到的冥想的好处包括：更容易入睡，改善暴躁的脾气和心态的改变（这一点在那些冥想超过1,000小时的人身上尤为明显，例如佛教徒们）。
- 如果你发现很难坚持完自己设定的冥想时间，那么就从短一点的冥想开始。几乎所有人都可以坚持一到两分钟不被任何杂念打扰的冥想。随后，等你脑海的波澜平息下来之后，试着一点点扩展冥想的时间，直到你能完成整个冥想过程为止。
- 长期冥想的好处十分明显，值得你坚持下去。这些好处包括：锻炼清醒意识、纾解压力、舒缓情绪、提高记忆力和注意力，增加大脑各部分的灰质（脑细胞）。

# *关于将项目上传到GitHub等仓库的操作

##**很重要很重要**

### push更新代码不成功，反而把本地代码弄丢

提交代码到远程分支，然后本地代码消失了，找回本地代码的操作：

1、执行命令：

> git reflog	

![](E:\issue_md\image\Snipaste_2021-12-20_18-15-11.jpg)

2、用reset (Suppose the old commit was HEAD@{5} in the ref log)

> git reset --hard HEAD@{9}
> 亲测有效！解决了～解决了～

###git的使用--上传到GitHub仓库的方法

####一.需要将GitHub上的仓库clone到本地的，然后将项目直接放进这个文件夹的（GitHub仓库）

1.安装git工具

https://git-for-windows.github.io/

2.注册github账号

https://github.com/

3.登录GitHub，进入首页，点击New

![](issue.assets/Snipaste_2021-12-15_15-46-44-16480059672561.jpg)

4.创建仓库

![](issue.assets/Snipaste_2021-12-15_15-49-32.jpg)

5.创建成功后可以看HTTPS地址和SSH地址

6.在要上传的项目目录里打开Git Bash Here

7.把GitHub上面的仓库克隆到本地

命令：git clone [url] 备注：[url] 是项目地址

8.然后本地文件夹会多出一个文件夹，文件夹名称即为GitHub上的地址

9.把要上传的项目文件全部移到新多出来的文件夹里

10.接着进入新的文件夹里或者cd进去，打开git bash here ，

命令：

1.git add .     备注：后面的小点‘.’代表所有文件都加进git的本地仓库里，也可以指定文件。

2.git commit -m "提交的描述"

3.git push -u origin master  （注：此操作目的是把本地仓库push到github上面，此步骤需要你输入帐号和密码，从2021.8.14号开始不支持密码验证了，改成token校验）

####二.本地已有项目仓库的(文件夹)，需要直接将项目上传到GitHub仓库的

1. 需要先创建一个本地的版本库，假设文件夹起名为pros（其实也就是一个文件夹）直接右击新建文件夹，也可以右击打开Git bash命令行窗口通过命令来创建；

2. 进入文件夹，通过命令 git init 把这个文件夹变成Git可管理的仓库 ，这时会多出一个 .git的文件夹，里面的config文件可以查看仓库地址；

3. 将项目粘贴到这个本地Git仓库pros里面,然后通过git add把项目添加到仓库（或git add .把该目录下的所有文件添加到仓库，注意点是用空格隔开的）。在这个过程中你其实可以一直使用git status来查看你当前的状态;

   **注意**：如果是从其他仓库转到自己的仓库的：需要先这样

   ```
    git rm -r --cached .
     git config core.autocrlf false
   
     git add .
   ```

   

4. 用git commit -m "注释内容" 把项目提交到仓库;

5. 由于本地Git仓库和Github仓库之间的传输是通过SSH加密的，所以连接时需要设置一下：创建SSH KEY。先看一下你C盘用户目录下有没有.ssh目录，有的话看下里面有没有id_rsa和id_rsa.pub这两个文件，有就跳到下一步，没有就通过下面命令创建。

   ```
   $ ssh-keygen -t rsa -C ``"youremail@example.com"` `注意ssh-keygen之间没有空格
   ```

   然后回车，询问保存key的位置，默认是在括号里的路径下，你可以修改，也可以不做修改

   可能提示要输入密码，为了不必要麻烦，还是不要设置密码，因为容易忘记，不输入密码，回车；确认密码不输入，回车

   这时你就会在用户下的.ssh目录里找到id_rsa和id_rsa.pub这两个文件

6.登录Github,找到右上角的图标，打开点进里面的Settings，再选中里面的SSH and GPG KEYS，点击右上角的New SSH key，然后Title里面随便填，再把刚才id_rsa.pub里面的内容复制到Title下面的Key内容框里面，最后点击Add SSH key，这样就完成了SSH Key的加密。具体步骤也可看下面：

![](E:\issue_md\image\Snipaste_2021-12-15_16-13-32.jpg)

![](E:\issue_md\image\Snipaste_2021-12-15_16-14-02.jpg)

![](E:\issue_md\image\Snipaste_2021-12-15_16-14-25.jpg)

![](E:\issue_md\image\Snipaste_2021-12-15_16-16-14.jpg)



7. 在Github上创建好Git仓库之后我们就可以和本地仓库进行关联了，根据创建好的Git仓库页面的提示，可以在本地pros仓库的命令行输入：注意origin后面加的是你Github上创建好的仓库的地址。

   ```
   git remote add origin [url]
   ```

​        

8. 关联好之后我们就可以把本地库的所有内容推送到远程仓库（也就是Github）上了，通过：

   git push -u origin master
   
   在这里可能需要输入账号密码，密码现在改成（token）

由于新建的远程仓库是空的，所以要加上-u这个参数，等远程仓库里面有了内容之后，下次再从本地库上传内容的时候只需下面这样就可以了：
$ git push origin master

###关于git的权限校验的问题

一、 如何生成自己的token
1、在个人设置页面，找到Setting（参考）

2、选择开发者设置Developer setting

3、选择个人访问令牌Personal access tokens，然后选中生成令牌Generate new token

4、设置token的有效期，访问权限等

选择要授予此令牌token的范围或权限。

要使用token从命令行访问仓库，请选择repo。
要使用token从命令行删除仓库，请选择delete_repo
其他根据需要进行勾选

5、生成令牌Generate token

如下是生成的token

注意：

记得把你的token保存下来，因为你再次刷新网页的时候，你已经没有办法看到它了，所以我还没有彻底搞清楚这个token的使用，后续还会继续探索！

6、之后用自己生成的token登录，把上面生成的token粘贴到输入密码的位置，然后成功push代码！

也可以 把token直接添加远程仓库链接中，这样就可以避免同一个仓库每次提交代码都要输入token了：

git remote set-url origin https://<your_token>@github.com/<USERNAME>/<REPO>.git

<your_token>：换成你自己得到的token
<USERNAME>：是你自己github的用户名
<REPO>：是你的仓库名称
例如：

git remote set-url origin https://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@github.com/shliang0603/Yolov4_DeepSocial.git/

二、 常见问题
有些问题我也没有遇到过，大家共同探讨吧，我会在评论区把大家遇到的问题做个汇总！

1、如果 push 等操作没有出现输入密码选项，请先输入如下命令，之后就可以看到输入密码选项了

git config --system --unset credential.helper
————————————————
原文链接：https://blog.csdn.net/weixin_41010198/article/details/119698015

##git的命令

###GIT基本操作

```crystal
# 暂时将未提交的变化移除，稍后再移入(对于切换分支又不想提交代码极为有效)
拉取代码时，本地有修改文件的拉取不成功时可以用下面这两条：
git stash   先隐藏本地修改
git stash pop    恢复本地修改

git init
git remote add origin [远程库地址]
git pull origin master
git add .
git commit -m "注释"
git push origin master

其他：
git status
git log
git branch
git checkout
git merge
```

##建立本地仓库

git init 创建本地仓库： git init [project-name]

git remote add origin git@github.com:UserName/yourProjectName.git  把本地仓库和远程仓库关联起来， 如果不执行这个命令的话，每次 push 的时候都需要指定远程服务器的地址

### 

git clone https://github.com/zhoulujun/yourProjectName.git

##提交本地修改到远程仓库中：

git add -- 将改动添加到本地仓库中  

- git add [file1] [file2] ... || git add [dir] 添加指定文件||目录到暂存区
- git add -A || git add .添加当前目录的所有文件到暂存区
- git add -p 添加每个变化前，都会要求确认，对于同一个文件的多处变化，可以实现分次提交

git rm xxx    -- 从本地仓库中删除指定文件

- git rm -r xxx  -- 从本地仓库中删除指定文件夹
- git rm --cached [file]
- git mv [file-original] [file-renamed] 改名文件，并且将这个改名放入暂存区

git commit -m "注释"   -- 把本机缓存中的内容提交到本机的 HEAD 里面

- git commit -a 提交工作区自上次commit之后的变化，直接到仓库区
- git commit -v 提交时显示所有diff信息
- git commit --amend -m [message] 使用一次新的commit，替代上一次提交，如果代码没有任何新变化，则用来改写上一次commit的提交信息
- git commit --amend [file1] [file2] ... 重做上一次commit，并包括指定文件的新变化

git push origin master -- 把本地的 commit(提交) push 到远程服务器上， origin 也就是之前 git remote add origin 那个命令里面的 origin，origin 替代了服务器仓库地址：git@github.com:zhoulujun/yourProjectName.git 

- git push remoteBranchName tagName提交指定tag
- git push remoteBranchName --tags 提交所有tag

##git转态查看

git remote update origin --prune 或者  git remote update origin --p    更新远程分支

git status 查看状态

git branch 查看本地所有分支

- git branch -r查看远程所有分支
- git branch -a查看本地和远程所有分支

git tag 列出所有tag

git show tagName 查看tag信息

git log --stat 显示commit历史，以及每次commit发生变更的文件

##分支操作

git checkout branchName 切换到指定分支，并更新工作区

git merge branchName 合并指定分支到当前分支

git branch newBranchName 新建一个分支，但依然停留在当前分支

git branch --track branch remote-branch 新建一个分支，与指定的远程分支建立追踪关系

git branch -D branchName //删除目标分支

git checkout -b branchName 新建并切换至新分支

git branch -d -r branchName 删除远程分支，其中

git branch -m oldbranchname newbranchname 重命名分支 使用-M则表示强制重命名

**重命名远程分支**

- git branch -m old_name new_name 重命名分支
- git checkout -b new_branch_name from_branch_name 本地建立 branch 並立即 checkout 切換過去
- git push origin –delete old_name

也可以如此操作

- git branch -m old_branch new_branch # Rename branch locally
- git push origin :old_branch # Delete the old branch
- git push --set-upstream origin new_branch 或者git push -u origin new_branch # Push the new branch, set local branch to track the new remote

###git分支与主干合并操作

####在主干上合并分支||主干合并分支

git merge branch --squash //提交合并后的代码

git commit -m ‘合并备注’

git push //将代码推送到远程仓库

####分支同步主干代码||在分支上合并主干

git merge master --squash //提交合并后的代码

git commit -m ‘合并备注’ //将代码推送到远程仓库

git push //将代码推送到远程仓库

####git强制覆盖本地代码

与git远程仓库保持一致

git fetch --all

git reset --hard origin/master

git pull

git强制覆盖本地命令（单条执行）：

git fetch --all && git reset --hard origin/master && git pull

####git修改远程仓库地址

方法有三种：

1.修改命令

git remote origin set-url [url]

2.先删后加

git remote rm origin

git remote add origin [url]

3.直接修改config文件

.git文件夹，找到config，编辑，把就的项目地址替换成新的。

##git 配置

git config --list     查看配置列表

git config --global user.name "xxx"  -- 配置用户名，上传本地 repository 到服务器上的时候，在 Github 上会显示这里配置的上传者信息

git config --global user.email "xxx"  -- 配置邮箱

**配置 sshkey** ： 上传代码时使用这个 sshkey 来确认是否有上传权限

  \1. 创建本地 ssh ： ssh-keygen -t rsa -C "Github 的注册邮箱"

  \2. 在 Github 中添加这个 sshkey ： 

​    复制  C:\Documents and Settings\Administrator\.ssh\id_rsa.pub 文件中的内容；

​    登录 Github --> Account Setting  --> SSH-KEY --> Add SSH-KEY --> 粘贴id_rsa.pub中的内容；

  \3. 验证： ssh -T git@github.com

​    出现 Hi xxx! You've successfully authenticated, but GitHub does not provide shell access. 说明配置成功，可以连接上 Github



**使用 .gitignore 文件忽略指定的内容**：

  \1. 在本地仓库根目录创建 .gitignore 文件。Win7 下不能直接创建，可以创建 ".gitignore." 文件，后面的标点自动被忽略；

  \2. 过滤文件和文件夹： [Tt]emp/ 过滤 Temp\temp 文件夹； *.suo 过滤 .suo 文件；

  \3. 不过滤文件和文件夹： !*.c

##git 的使用报错

####1.

```
> git pull --tags origin master
From https://gitlab.hundsun.com/aiInsVideo/avs-web
 * branch            master     -> FETCH_HEAD
fatal: refusing to merge unrelated histories
```

问题描述：

当本地分支与远程分支没有共同祖先时，会出现 `fatal: refusing to merge unrelated histories` 的问题。

解决：git pull --rebase origin master

####2.

> ```
> git push origin master:master
> remote: GitLab: You are not allowed to push code to protected branches on this project.        
> To https://gitlab.hundsun.com/aiInsVideo/avs-web.git
>  ! [remote rejected] master -> master (pre-receive hook declined)
> error: failed to push some refs to 'https://gitlab.hundsun.com/aiInsVideo/avs-web.git'
> ```
>
> 问题描述：
>
> 没有权限上传到相应分支

####3.如果一个分支没有master上的内容 可以选择将master分支合并到该分支上

没有在当前分支：用 命令：git branch 查看分支

```
$ git branch

* (no branch, rebasing master)
  feature_20211220
  master
```

本次出现这个错误是因为本地提交了`commit`但是未`push`成功，所以使用`git pull --rebase`，由于远程仓库和本地的`commit`有冲突，Git无法自动解决冲突时，会切换到一个匿名分支，然后使用`git branch`发现报错“no branch, rebasing master”。

解决办法：
 在当前匿名分支下，解决完冲突，然后使用命令`git rebase --continue`，可以将代码合并到之前操作时的分支（我当时是在master分支所以后面都说master分支），执行完`git rebase --continue`后就自动回到了master分支，但是之前提交的`commit`没有在本地仓库区(Repository)了，回到了本地暂存区(Index / Stage)，这时候需要重新`commit`，之后再执行`git push origin master`就可以将变更推到远程仓库了。

今天使用 git pull和git push 命令，分别报错：

You are not currently on a branch, so I cannot use any
'branch.<branchname>.merge' in your configuration file.
Please specify which remote branch you want to use on the command
line and try again (e.g. 'git pull <repository> <refspec>').
See git-pull(1) for details.

fatal: You are not currently on a branch.
To push the history leading to the current (detached HEAD)
state now, use

    git push origin HEAD:<name-of-remote-branch>

这是什么意思呢？
说我当前不是在分支上，因此不能 pull 或者 push

然后利用git branch查看一下，发现：

git branch
* (HEAD detached from bdcfe3d8)
* master
* issue68

我当前所处的位置是在HEAD detached from bdcfe3d8上

所以进行如下操作

git branch temp bdcfe3d8
git checkout master
git merge temp

这三行命令的意思是：

依据快照bdcfe3d8 创建 temp 分支
切换到 master 分支
将 temp 分支合并到 master分支
再看一下所有的分支

git branch
* master
* issue68
* temp

这时候就可以进行 git pull 和 git push 了
记得删除 temp 分支哦

git branch -d temp

####4.提交代码到远程仓库时的报错： fatal: unable to access 'https://github.com/lerojon/FrontendTools.git/': OpenSSL SSL_read: SSL_ERROR_SYSCALL, errno 10054 

第一种方法：

第一条：这条会报错，继续下一条命令

```
git config http.sslVerify "false"
```

第二条：

```
git config --global http.sslVerify "false"
```

再次克隆会报错，那就是原先执行clone时的那份文件没删除，删除，然后重新执行git clone命令

第二种方法：

- git_bash 执行 `git config --global --unset http.proxy` 命令或`git config --global --unset https.proxy`

####5.改变项目的仓库地址(The file will have its original line endings in your working directory)

```
此时需要执行如下代码：

  git rm -r --cached .
  git config core.autocrlf false

  git add .

. 代表当前目录
```

####6.使用git clone时报错

```
ssh:could not resolve hostname https:name or service not known fatal:could not read from remote repository
```

问题描述
在clone某个github项目到本地时，报该错误，clone项目失败

解决过程
首先检查网络问题。使用ping命令ping github.com。结果显示找不到主机名
进一步使用ping命令ping其他网址，如百度等，结果正常，说明网络正常，可能DNS解析出现问题
修改DNS域名，结果仍然失败
在本地host文件下，添加github的ip地址项(修改host文件可能需要更改权限)
修改之后，git clone命令运行成功！

## git项目分支回滚

本文 git 相关命令：

git reset：回退版本，可指定某一次提交的版本。git reset [--soft | --mixed | --hard] commitId。

git revert：撤销某个提交，做反向操作，生成新的commitId，原有提交记录保留。git revert commitId。

git status：查看文件在工作区和暂存区的状态。

git log：查看代码提交记录。

git cherry-pick：选择commitId 应用在当前分支。git cherry-pick commitId。

###回退分两种情况：

已 commit，未push到远程仓库。

已 commit，并且push到了远程仓库。

####已 commit，未push到远程仓库

 一.git reset --soft（撤销commit）

执行命令： git reset --soft [通过git log 获取的id(版本号)]	

二.git reset --mixed（撤销 commit 和 add 两个动作）

#### 已 commit，并且push到了远程仓库

一：git reset --hard（撤销并舍弃版本号之后的提交记录）

执行命令：

1.git reset --hard [要回退的版本号]

2.git push -f     （强制推送到远程，之前提交都会被覆盖，慎用）

二：git revert（撤销，但是保留了提交记录）

执行命令：

1.git revert [版本号]

2.git cherry-pick [版本号（跟revert时的版本号一样）]

4.git push

推荐用这种方式回退远程的代码。比如我们在master分支提交错了文件需要回退，那么我们用这个方式回退后，再用git cherry-pick commitId 重放该提交。最后本地修改了再push到远程。

# *git的提交规范

##提交格式：

```
<type>(<scope>): <subject>
// 空一行
<body>
```

##范例:

```
feat(model): add model

增加用户模型
```

##提交的具体情况

- `<type>` （必需）用于说明 commit 的类别，只允许使用下面8个标识。

  ```
  br: 此项特别针对bug号，用于向测试反馈bug列表的bug修改情况
  feat：新功能（feature）
  fix：修补bug
  docs：文档（documentation）
  style： 格式（不影响代码运行的变动）
  refactor：重构（即不是新增功能，也不是修改bug的代码变动）
  test：增加测试
  chore：构建过程或辅助工具的变动
  revert: feat(pencil): add 'graphiteWidth' option (撤销之前的commit)
  ```

- `<scope>` （可选）说明 commit 影响的范围，比如数据层、控制层、视图层等等，视项目不同而不同。

- `<subject>` （必需）commit 目的的简短描述，不超过50个字符。
  以动词开头，使用第一人称现在时，比如change，而不是changed或changes
  第一个字母小写
  结尾不加句号（.）

- `<body>` (可选) 部分是对本次 commit 的详细描述，可以分成多行。





#*vue使用import来引入组件的注意事项



Vue使用import ... from ...来导入组件，库，变量等。而from后的来源可以是js，vue，json。这个是在webpack.base.conf.js中设置的：

```json
module.exports = {
      resolve: {
        extensions: ['.js', '.vue', '.json'],
        alias: {
          '@': resolve('src')
        }
      }
    ...
    }
```

 

这里的extensions指定了from后可导入的文件类型。

而上面定义的这3类可导入文件，js和vue是可以省略后缀的：

import test from './test.vue'  等同于： import test from './test'

同理：

import test from './test.js' 等同于：import test from './test'

json不可以省略后缀


那么，若test.vue，test.js同时存在于同一个文件夹下，则import的导入优先级是：js>vue

 from后的来源除了文件，还可以是文件夹：import test from './components'

该情况下的逻辑是：

  if(package.json存在 && package.main字段存在 && package.main指定的js存在) {
    取package.main指定的js作为from的来源，即使该js可能格式或内容错误
  } else if(index.js存在){
    取index.js作为from的来源
  } else {
    取index.vue作为from的来源
  }

因此**若from的来源是文件夹，那么在package.json存在且设置正确的情况下，会默认加载package.json；若不满足，则加载index.js；若不满足，则加载index.vue**。

注意加载文件夹的形式，与上面省略后缀的形式是完全相同的。所以**一个省略后缀的from来源，有可能是.vue，.js，或者文件夹**。

例：查看Vue-Element-Admin的源码，其中有个Layout.vue：

里面调用import导入了3个组件：

import { Navbar, Sidebar, AppMain } from './components'。 这里，from的路径'./components'就是个文件夹。

于是，按照前面的规则，首先查看文件夹下是否有package.json：

并没有package.json。

package.json不存在，那么查找index.js。index.js是存在的，于是加载。

打开index.js：

  export { default as Navbar } from './Navbar'

  export { default as Sidebar } from './Sidebar'

  export { default as AppMain } from './AppMain'

可以看到3个export，都没有后缀，所以其类型vue，js和文件夹都是有可能的。

同一级目录下，存在AppMain.vue和Navbar.vue，没有同名js，所以可以判断出这两个都是加载的vue文件，即：

  export { default as Navbar } from './Navbar.vue'

  export { default as AppMain } from './AppMain.vue'

而Sidebar只有一个文件夹，所以是加载的文件夹。打开Sidebar文件夹：

优先找package.json。不存在。然后找index.js，不存在。最后找index.vue，存在。

于是：

export { default as Sidebar } from './Sidebar'  相当于：export { default as Sidebar } from './Sidebar/index.vue'

这样，Layout.vue就通过加载一个文件夹，获得了3个vue组件。

#*npm相关

##一：npm 的报错

**如果使用了nvm，npm的时候报错很有可能是node的版本不对**



/AppData/Local/npm-cache/_logs

1.删除node_modules文件

2.npm cache clean --force

3.npm install

<h3>网上搜索的解决方法</h3>

出现的问题：

    npm ERR! path D:\CIM_vue\package.json
    npm ERR! code ENOENT
    npm ERR! errno -4058
    npm ERR! syscall open
    npm ERR! enoent ENOENT: no such file or directory, open 'D:\CIM_vue\package.json'
    npm ERR! enoent This is related to npm not being able to find a file.
    npm ERR! enoent
    npm ERR! A complete log of this run can be found in:
    npm ERR!    
    ..\Roaming\npm-cache\_logs\2019-09-16T01_41_51_803Z-debug.log

解决方案一：

首先初始化，再安装相应的文件

 1.  npm init -f //强迫初始化文件
 2.  npm install bluebird --save

解决方案二：

npm run dev 时报错 ，package.json找不到

也有可能是因为是没进入到文件目录里，进到文件的目录中再去npm run dev 就不会报错了！
cmd 黑窗口 cd进入项目 npm run dev 或者 打开本地项目所在文件夹，再地址栏上输入cmd 回车直接进入当前项目下。

解决方案三：

我们使用命令 npm install xxx安装包时，默认是从 npm
的的镜像源服务器进行下载的，由于该服务器是放在国外，很容易就导致安装失败。因此 我们需要修改镜像源地址。 全局安装nrm 镜源管理器
nrm里面存放了多个镜像服务器

npm install  nrm    -g
1
先清除缓存，再重新安装

npm cache clean --force
1
重新安装

npm install
1
解决方案四：

全局更新 npm

npm i npm -g 就ok了
————————————————

原文链接：https://blog.csdn.net/o_o814222198/article/details/100877846

-----------------issue



### 2.安装webpack 打包依赖后   vue-cli项目运行npm run dev / npm run serve后报错：

![](issue.assets/Snipaste_2022-04-15_14-25-54.jpg)

####原因：
某些新版本的库要求 webpack@5，更新依赖时，根据依赖选择的规则，就以 webpack@5 作为主依赖安装。然而 @vue/cli 依赖 webpack@4，它自带的 webpack 配置无法兼容 webpack@5 ，于是就报错，不能继续编译。如果你也在使用 @vue/cli，那么请不要贸然升级 webpack@5。

####解决方案1：
先删掉 node_modules 和 package-lock.json
手动在 package.json 的 devDependencies 里添加 “webpack”: “^4.23.0”,
重新安装全部依赖： npm install
重新运行，发现问题解决
参考文章：
https://blog.meathill.com/fe-tool-chain/how-to-fix-error-rule-can-only-have-one-resource-source-provided-resource-and-test-include-exclude.html

#### 解决方案2：

卸载已安装的高版本webpack

```
npm uninstall webpack
```

再安装低版本的webpack

```
npm install webpack@^4.0.0 --save-dev
```



###3.Require stack: 需要堆栈

报错信息：

```
ModuleBuildError: Module build failed (from ./node_modules/stylus-loader/index.js):
Error: Cannot find module 'webpack'
Require stack:
- D:\aaa-DaGongRen\ivideo\ivideo-web-new\ivideo-web\node_modules\stylus-loader\index.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\node_modules\loader-runner\lib\loadLoader.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\node_modules\loader-runner\lib\LoaderRunner.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\lib\NormalModule.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\lib\NormalModuleFactory.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\lib\Compiler.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\webpack\lib\webpack.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\vue-loader\lib\plugin.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\node_modules\vue-loader\lib\index.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\lib\plugins\base.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\lib\Service.js
- C:\Users\11190\.hui\lib\node_modules\@hui\bundler\lib\index.js
- D:\node\node-v14.1.0\node_modules\@hui\cli\node_modules\hui-shared\lib\service.js
- D:\node\node-v14.1.0\node_modules\@hui\cli\node_modules\hui-shared\lib\plugin\PluginAPI.js
- D:\node\node-v14.1.0\node_modules\@hui\cli\node_modules\hui-shared\lib\plugin\index.js
- D:\node\node-v14.1.0\node_modules\@hui\cli\node_modules\hui-shared\lib\index.js
- D:\node\node-v14.1.0\node_modules\@hui\cli\bin\hui.js
    at Function.Module._resolveFilename (internal/modules/cjs/loader.js:1020:15)
    at Function.Module._load (internal/modules/cjs/loader.js:890:27)
    at Module.require (internal/modules/cjs/loader.js:1080:19)
    at Module.require (C:\Users\11190\.hui\lib\node_modules\@hui\bundler\lib\hacker.js:21:21)
    at require (internal/modules/cjs/helpers.js:72:18)
    at Object.<anonymous> (D:\aaa-DaGongRen\ivideo\ivideo-web-new\ivideo-web\node_modules\stylus-loader\index.js:183:27)
```

原因可能是：下载node-sass失败

1解决方法：

```
首先执行：npm install -g cnpm --registry=https://registry.npm.taobao.org

再执行：cnpm install node-sass --save
```

2解决方法：

```
npm install --save-dev node-sass --registry=https://registry.npm.taobao.org --disturl=https://npm.taobao.org/dist --sass-binary-site=http://npm.taobao.org/mirrors/node-sass

```

##二.npm 命令

### 1.查看已全局安装的依赖包 

分为 npm 和 yarn 不同安装

```
npm —>  npm list -g --depth 0 

yarn —->  yarn global list --depth=0 
```



查看npm 全局安装的路径和依赖包

```
npm ls -g
```



#*node-moudle 依赖模块报错

###1.在babel.config.js删除相应报错插件即可

###2.**解决style lang="***scss***"的问题**

Vue安装sass的命令：

1、npm install node-sass --save-dev

2、npm install sass-loader --save-dev

在进行第一步的时候，我们会发现用报了下面这个的错，在百度一下问题的时候，发现原因是：

首先要知道的是，安装 node-sass 时在 node scripts/install 阶段会从 github.com 上下载一个 .node 文件，大部分安装不成功的原因都源自这里，因为 GitHub Releases 里的文件都托管在 s3.amazonaws.com 上面，而这个网址在国内总是网络不稳定，所以我们需要通过第三方服务器下载这个文件。

解决方法：
1、首先安装淘宝镜像

$ npm install -g cnpm --registry=https://registry.npm.taobao.org
2、 用cnpm重新安装一次

cnpm install node-sass --save-dev

cnpm install sass-loader --save-dev


可能报错"版本过高导致的"

解决办法:

npm uninstall sass-loader（卸载当前版本）卸了重新安装了一个低版本的就好了。npm install sass-loader@7.3.1 --save-dev

#*vscode 编译报错的问题

ERROR  Failed to compile with 1 errors

    <br>This relative module was not found:




![](E:\issue_md\image\Snipaste_2021-11-18_09-01-09.jpg)





#*组件的报错

vue错误提示：Invalid default value for prop "queryRoleList": Props with type Object/Array must use a factory function to return the default value.

然后在报错的文件会自动生成引入

import func from '../../../vue-temp/vue-editor-bridge'

终端报错提示：This relative module was not found:

* ../../../vue-temp/vue-editor-bridge in ./node_modules/babel-loader/lib!./node_modules/vue-loader/lib/selector.js?type=script&index=0!./src/components/universalityComs/dialogForm.vue

解决报错：删除 import func from '../../../vue-temp/vue-editor-bridge'即可

并且props的默认值是数组的改成函数返回数组



#*element input框限制输入格式为数字

月份数，薪资、电话号码等的 input 框需要限制只能输入数字类型内容

1.实现：监听键盘输入，使用正则过滤掉其他字符

```
οninput="value=value.replace(/^\.+|[^\d.]/g,'')
```



```
<el-input   
    v-model.trim="emp_work_experience.dimission_salary" 
    placeholder="请输入薪资"   
    oninput="value=value.replace(/^\.+|[^\d.]/g,'')">
</el-input>
```

2.遇到坑：然后遇到了一个问题，当输入其他字符再输入数字的时候，输入框中显示有值，但实际去打印 v-model绑定的变量的时候就获取不到新输入值。即使用了一个函数限制输入框只能输入数字，输入其他将会被置空，在输入1时是正确的，之后我们输入一个非数字，这个非数字并被置空之后，再输入新的数字。v-model的值和value的值出现了不同，v-model无法获取到新输入的数值。

详细原理解析：（参考大佬的）

https://blog.csdn.net/qq_41635167/article/details/857369363.

3.解决：在输入框失去焦点的时候，把value值赋值给v-model绑定变量，使两者保持一致

3.解决：在输入框失去焦点的时候，把value值赋值给v-model绑定变量，使两者保持一致

```
<el-input   
    v-model.trim="emp_work_experience.dimission_salary" 
    placeholder="请输入薪资"   
    oninput="value=value.replace(/^\.+|[^\d.]/g,'')"
    @blur="salaryChange">
</el-input>
```

 

js:
//月薪改变

```
function salaryChange(e){
     this.emp_work_experience.dimission_salary = e.target.value
}
```

#*单点登录





#*[vue的watch监听函数](https://www.cnblogs.com/whx123/p/12122732.html)

在vue中，使用watch来响应数据的变化。watch的用法大致有三种。下面代码是watch的一种简单的用法：

```
1.
<input type="text" v-model="cityName"/> new Vue({
   el: '#root',
   data: {
     cityName: 'shanghai'
   },   methods:{     Namechange:function(){        .....     }
   },
   watch: {
     cityName(newName, oldName) {        console.log(newName)
        console.log(oldName)
     }
   } 
 }) 也可以直接写一个监听处理函数，当每次监听到 cityName 值发生改变时，执行函数。也可以在所监听的数据后面直接加字符串形式的方法名： watch:{   citiName:'Namechange' }
```

 **2.immediate（立即处理 进入页面就触发）** **和 handler :**

​    这样使用watch时有一个特点，就是当值第一次绑定的时候，不会执行监听函数，只有值发生改变才会执行。如果我们需要在最初绑定值的时候也执行函数，则就需要用到immediate属性。

​    比如当父组件向子组件动态传值时，子组件props首次获取到父组件传来的默认值时，也需要执行函数，此时就需要将immediate设为true。

​    new Vue({

```
     el: '#root',
     data: {
        cityName: ''
     },
     watch: {
        cityName: {
    　　   handler(newName, oldName) {
      　　    // ...
    　　   },
    　　 immediate: true        }
     } 
  })
```

  监听的数据后面写成对象形式，包含handler方法和immediate，之前我们写的函数其实就是在写这个handler方法；

  immediate表示在watch中首次绑定的时候，是否执行handler，值为true则表示在watch中声明的时候，就立即执行handler方法，值为false，则和一般使用watch一样，在数据发生变化的时候才执行handler。

 **3.deep : 深度监听**

  **当需要监听一个对象的改变时，普通的watch方法无法监听到对象内部属性的改变，只有data中的数据才能够监听到变化，此时就需要deep属性对对象进行深度监听。**

```
   <input type="text" v-model="cityName.name"/>
    new Vue({
      el: '#root',
      data: {
        cityName: {id: 1, name: 'shanghai'}
      },
      watch: {
        cityName: {
          handler(newName, oldName) {
           // ...
       },
        deep: true,
        immediate: true
      }
    })   设置deep: true 则可以监听到cityName.name的变化，此时会给cityName的所有属性都加上这个监听器，当对象属性较多时，每个属性值的变化都会执行handler。如果只需要监听对象中的一个属性值，则可以做以下优化：使用字符串的形式监听对象属性      
    watch: {
       'cityName.name': {
           handler(newName, oldName) {
          // ...
        },
        deep: true,
        immediate: true
       }
    }
```

​     这样只会给对象的某个特定的属性加监听器。数组（一维、多维）的变化不需要通过深度监听，对象数组中对象的属性变化则需要deep深度监听。

 

 

 Watch 与 computed的区别：

​    Watch：watch用于观察和监听页面上的vue实例，当你需要在数据变化响应时，执行异步操作，或高性能消耗的操作，那么watch为最佳选择

   computed ：可以关联多个实时计算的对象，当这些对象中的其中一个改变时都会触发这个属性具有缓存能力，所以只有当数据再次改变时才会重新渲染，否则就会直接拿取缓存中的数据。

# *uniapp项目出现的问题

##1，编译问题

![](E:\issue_md\image\Snipaste_2021-12-14_15-39-41.jpg)

uniapp项目点击运行一直卡在 “开始编译...” 这一步，网上说的卸载hbx和用管理员运行均不可以。后来改用命令行‘npm run serve’ 运行直接在![](E:\issue_md\image\Snipaste_2021-12-14_15-43-02.jpg)

这里就中断了， 然后按这个在网上搜问题，原来是nodejs内存溢出的原因，修改node内存限制，重启后就好了；

查询后了解到是Node中通过JavaScript使用内存时只能使用部分内存（64位系统：1.4 GB，32位系统：0.7 GB），如果前端项目比较大，Webpack编译时就会占用很多的系统资源，一旦超出了[V8引擎](https://www.jianshu.com/p/4757158528e7)对Node默认的内存限制大小时，就会产生内存溢出的错误。
 处理方式是：在package.json中script下添加

![](E:\issue_md\image\Snipaste_2021-12-14_15-47-24.jpg)

接着执行 `npm install cross-env --save--dev`(目前这里只能使用npm)
 以及 `npm install increase-memory-limit --save--dev`
 如果安装失败则需要先删除掉项目的node_modules包
 配置并安装成功后执行`npm run fix-memory-limit`这句，成功则会出现一下界面

![](E:\issue_md\image\Snipaste_2021-12-14_15-48-07.jpg)

引用：https://www.jianshu.com/p/9c60b283bb49



## 2.window下 NODE_ENV 环境变量的设置

方法：

**使用插件cross-env**

```
npm install cross-env
```

在package.json中加入 ```"start": "cross-env NODE_ENV=development node your-app-name.js"``

在cmd再

```
npm start
```

之后在node文件中，看一看相关的应用到判断环境变量再执行的代码



```
if (process.env.NODE_ENV === 'development') {
  
}
```


作者：liyuanzhe-cn
链接：https://juejin.cn/post/6844903838604869646



# *请求接口url报错相关

##接口地址错误的问题

![](E:\issue_md\image\Snipaste_2021-12-17_15-15-57.jpg)

![](E:\issue_md\image\Snipaste_2021-12-17_15-17-10.jpg)

![](E:\issue_md\image\Snipaste_2021-12-17_15-18-49.jpg)

![](E:\issue_md\image\Snipaste_2021-12-17_15-19-08.jpg)

怀疑是编译器的问题，代码都没有问题

# *VSCode 编译器

## 1.输入元素 提示带abc 的 而不是一个扳手图标的问题

快捷键：Alt + W 设置

## 2.格式化配置不生效的问题

选择默认格式化插件Vetur即可

![](E:\issue_md\image\Snipaste_2021-12-29_15-17-56.jpg)

![](E:\issue_md\image\Snipaste_2021-12-29_15-18-19.jpg)

# *element组件的问题

## vue+element el-select 选项无法选择的问题

出现这个问题就是绑定了对象（需求如此），render函数没有自动更新，数据刷新了，但是视图没有刷新，而this.$ste和this.$forceUpdate就是重新render。

解决办法：

1.通过this.$set()解决

Change(item){

​    ~~**this.$set(this.form.customs.businessType)**~~

​    console.log(item);

   },

###注意,修改this.$set()的使用方法

> 对this.$set()方法进行了多次尝试,发现存在bug
>
> 正确的写法应该是:
>
> Change(item){    this.$set(,,item)    console.log(item);   }, 
>
> 向this.$set() 里传入3个参数, 第一个是包裹字段的**父级对象**, 第二个是**目标字段**, 第三个是将要**赋值给目标字段的数据**

2.通过 this.$forceUpdate()解决

Change(item){

​    this.$forceUpdate()；

​    console.log(item);

   },

作者：风雨兼程620
链接：https://www.jianshu.com/p/bbbea54697ea
来源：简书

# *关于接口请求URL的问题

## 1.如果请求的基础路径没有带http://那么在浏览器的开发者模式中的Network 看到下面的url

![](E:\issue_md\image\Snipaste_2022-01-24_16-40-32.jpg)

```
Request URL: 

http://localhost:8090/172.27.28.196:19090/setting/product/queryAll
```

#*[window.open新打开窗口与新开标签页](https://www.cnblogs.com/wonyun/p/5284163.html)

最近在使用window.open时忽略了一个细节问题：window.open新打开一个窗口，但是有时却是新打开一个窗口有时打开一个新标签页。虽然对一般的需求来说，这个两种情况都无所谓，但是对于那种有强烈区分的需求来说还是要注意的。那么怎么会出现这种不同的打开情况呢，这要从window.open方法的用法和不同浏览器来区分。

------

###  1、window.open的用法容易忽视的细节

 window.open方法有三个参数：　　

```
window.open(url, [name], [configuration])
```

其中：

- url， 为要新打开页面的url
- name，为新打开窗口的名字，可以通过此名字获取该窗口对象
- configuration，为新打开窗口的一些配置项，比如是否有菜单栏、滚动条、长高等等信息

例如，新打开一个没有菜单栏、标题栏、工具栏，但是有滚动条、状态栏、地址栏且可伸缩窗口的方法调用如下：

```
window.open("index.html","newWindow","menubar=0,scrollbars=1, resizable=1,status=1,titlebar=0,toolbar=0,location=1");
```

以上只是简要描述了window.open的方法，但是这个方法容易忽略的地方就是：**新打开窗口名字可以是自定义的值，此外还可以是以下几个值，与超链接a的target属性值相同**

| **窗口name值** | **描述**                      |
| -------------- | ----------------------------- |
| _blank         | 默认的，在新窗口打开链接的url |
| _self          | 在当前窗口打开链接url         |
| _parent        | 在父窗口打开链接url           |
| _top           | 在顶级窗口打开url             |
| framename      | 在指定的框架中打开链接url     |

### 2、window.open打开新窗口还是打开新标签页

 调用window.open是打开新窗口，还是打开新标签页，其实没有什么要紧关系，但是有些需求在这方面有很强的意愿时，那就得区分一下了。具体的打开什么还是根据具体情况来定的，以下结论是经过本人测试得出的，若有不正确的地方，请大家批评指正。

1、window.open(url)或者window.open(url, name),其中name为_blank

- 标准浏览器、IE9+是新标签打开链接url
- ie6-8是新窗口打开链接url

2、window.open(url, name)，其中name为非_blank的其他4个值

　　此时会会在指定窗口或者frame打开链接url

3、window.open(url, name, configration)

　　**只要配置了configration，所有浏览器都是新窗口打开链接url**

 

### 3、使用window.open方法打开的窗口可能被拦截的替代方案

 现在有些浏览器为了安全起见，可能会阻止window.open打开的链接url，不管是以标签还是以窗口打开。这时可能需要用户进行浏览器设置允许弹新页，让用户设置浏览器是极不可取的做法，尤其像电商类网站，那么有其他替代方案呢？

答案当然是有的，**利用超链接打开的url是不会被拦截的可以实现这一点**。具体做法是结合事件手动触发机制。下面是  [HTML：模拟链接被按下，在新标签页打开页面，不使用window.open(可能被拦截)](http://www.cnblogs.com/0banana0/p/3566347.html) 这篇博客给的一个简单的实例，这篇文章给出的事件分发机制是针对标准浏览器的：

```
html>
<head>
    <meta http-equiv="Content-type" content="text/html; charset=utf-8">
    <title>Title</title>

    <script src="jquery.js"></script>
    <script type="text/javascript">
    $(function() {
        $("#btn").click(function() {
            //var a = $('a')[0];
            var a = $("<a href='http://www.apple.com' target='_blank'>Apple</a>").get(0);
            
            var e = document.createEvent('MouseEvents');
            e.initEvent( 'click', true, true );
            a.dispatchEvent(e);
        });
    });
    
    </script>
</head>

<body>
    <input type="button" value="Go to Apple" id="btn">
</body>
</html>
```

#*webpack-App

###1.关于静态文件路径的问题

可根据实际情况自行设定

*如果你计划在子路径下部署你的站点，你需要设置这个参数，

*例如GitHub页面。如果您计划将站点部署到https://foo.github.io/bar/，

*那么assetblicpath应该设置为“/bar/”。

*大多数情况下请使用“/”!!

```
build: {
    // Template for index.html
    index: path.resolve(__dirname, '../dist/index.html'),

    // Paths
    assetsRoot: path.resolve(__dirname, '../dist'),
    assetsSubDirectory: 'static',
    assetsPublicPath: '/',  //打包出来的静态js css html 的路径地址是 http://...... /static/js、css、html/这样的
    assetsPublicPath: './',  //打包出来的静态js css html 的路径地址是 http://......  ./static/js、css、html/这样的
    assetsPublicPath: '/abc',  //打包出来的静态js css html 的路径地址是 1.期望的地址http://......  /abc/static/js、css、html/...这样的
    2.事实打包放服务器上的地址： http://......  /abcstatic/js、css、html/...   添加的路径与static没有斜杆分割
    assetsPublicPath: '/abc/',  //打包出来的静态js css html 的路径地址是 http://......  /abc/static/js、css、html/...这样的
   
```

注意：![](E:\issue_md\image\Snipaste_2022-03-17_10-52-33.jpg)

这两个路径不正常的时候会在打包的时候报错，无法打包



###2.webpack 创建过程 ，文件的创建， 安装依赖 、插件的顺序都记录下来 

1.创建文件夹：

├─src
|  ├─generateJoke.js
|  └index.js
├─dist
|  └index.html

2. 如果没有webpack打包 使用：

   ```
   import ... from "..."
   ```

   引入文件会报错：

   ```
   Uncaught SyntaxError: Cannot use import statement outside a module (at index.js:1:1)
   ```

   所以按照webpack 打包依赖：

   ```
   先初始化：npm init -y
   
   npm i -D webpack webpack-cli
   ```

3.在package.json里的scripts对象里将test属性改成：

```
"build":"webpack --mode production"
```

然后运行：

```
npm run build

终端输出：
> webpack-App2@1.0.0 build E:\demo\webpack-App2
> webpack --mode production

asset main.js 45 bytes [emitted] [minimized] (name: main)
orphan modules 80 bytes [orphan] 1 module
./src/index.js + 1 modules 154 bytes [built] [code generated]
webpack 5.72.0 compiled successfully in 239 ms

```

这时dist文件夹多了一个文件：main.js

然后将index.html 的 脚本src路径 改成main.js 报错消失 成功运行输出

4.在根目录下创建webpack的配置文件：webpack.config.js

```
const path = require('path')
module.exports={
    mode:'development', //package.json的脚本可以去掉 “--mode production”
    entry:path.resolve(__dirname, 'src/index.js'), //配置入口文件
    output:{ //出口配置
    path:path.resolve(__dirname, 'dist') //出口文件（例如main.js）
    filename:'bundle.js' //打包文件的指定文件名 运行npm run build 就会在dist生成bundle.js(没有设置filename的时候默认是main.js)
    }，
}
```



已上面的相比：entry变成了一个对象

```
const path = require('path')
module.exports={
    mode:'development', //package.json的脚本可以去掉 “--mode production”
    entry:{
     bundle:path.resolve(__dirname, 'src/index.js'), //配置入口文件
    },
    output:{ //出口配置
    path:path.resolve(__dirname, 'dist') //出口文件（例如main.js）
    filename:'[name].js' //打包文件的指定文件名 运行npm run build 就会在dist生成bundle.js(没有设置filename的时候默认是main.js)
    }，
}
```

5.配置插件

```
npm i -D sass style-loader css-loader sass-loader
```

6.在src下创建文件夹styles并创建main.scss

```
├─package-lock.json
├─package.json
├─webpack.config.js
├─src
|  ├─generateJoke.js
|  ├─index.js
|  ├─styles
|  |   └main.scss
├─dist
|  ├─bundle.js
|  └index.html
```

在src 的 index.js 引入main.scss

```
import './styles/main.scss'

运行npm run build 会报错
> webpack-App2@1.0.0 build E:\demo\webpack-App2
> webpack

asset bundle.js 5.66 KiB [emitted] (name: main)
runtime modules 937 bytes 4 modules
cacheable modules 1.47 KiB
  ./src/index.js 101 bytes [built] [code generated]
  ./src/generateJoke.js 80 bytes [built] [code generated]
  ./src/styles/main.scss 1.29 KiB [built] [code generated] [1 error]

ERROR in ./src/styles/main.scss 1:0
Module parse failed: Unexpected character '@' (1:0)
You may need an appropriate loader to handle this file type, currently no loaders are configured to process this file. See https://webpack.js.org/concepts#loaders
> @import url('https://fonts.googleapis.com/css2?family=Roboto:wght@400;700&display=swap');
| $primary-color:#2fa8cc;
| $secondary-color:#f4f4f4;
 @ ./src/index.js 2:0-27

webpack 5.72.0 compiled with 1 error in 95 ms
npm ERR! code ELIFECYCLE
npm ERR! errno 1
npm ERR! webpack-App2@1.0.0 build: `webpack`
npm ERR! Exit status 1
npm ERR!
npm ERR! Failed at the webpack-App2@1.0.0 build script.
npm ERR! This is probably not a problem with npm. There is likely additional logging output above.

npm ERR! A complete log of this run can be found in:
npm ERR!     C:\Users\96135\AppData\Roaming\npm-cache\_logs\2022-04-22T16_42_17_395Z-debug.log
```

webpack.config.js添加module对象

```
module:{
      rules:[
          {
              test:/\.scss$/,
              use:['style-loader', 'css-loader', 'sass-loader']
          }
      ]
  }
  
  //配置了规则之后 报错消失
```

7.下载插件：

```
npm i -D html-webpack-plugin
```

```
const path = require("path")
const HtmlWebpackPlugin = require("html-webpack-plugin")
module.exports = {
  mode: "development",
  entry: path.resolve(__dirname, "src/index.js"),
  output: {
    path: path.resolve(__dirname, "dist"),
    filename: "bundle.js",
  },
  module: {
    rules: [
      {
        test: /\.scss$/,
        use: ["style-loader", "css-loader", "sass-loader"],
      },
    ],
  },
  plugins: [ //配置了这个 再次运行npm run build 会自动生成dist文件夹 此时如果在index.html写内容 再次运行npm run build 是不生效的
    new HtmlWebpackPlugin({
      title: "Webpack App",
      filename: "index.html",
      template:'src/template.html',//在相应的文件下创建template.html文件夹 
    }),
  ],
}

```

8.安装webpack的服务依赖 这样不用每次修改代码都要运行npm run build

```
在package.json 的脚本里添加 'dev':"webpack serve"
"scripts": {
        "build": "webpack",
        "dev": "webpack serve"
    },
    
    然后运行 npm run dev 会提示是否安装webpack-dev-serve
    
> webpack-App2@1.0.0 dev E:\demo\webpack-App2
> webpack serve

[webpack-cli] For using 'serve' command you need to install: 'webpack-dev-server' package.
[webpack-cli] Would you like to install 'webpack-dev-server' package? (That will run 'npm install -D webpack-dev-server') (Y/n)
 
 
 安装之后会有一个端口： 8080
 <i> [webpack-dev-server] Project is running at:
<i> [webpack-dev-server] Loopback: http://localhost:8080/
<i> [webpack-dev-server] On Your Network (IPv4): http://192.168.3.158:8080/
<i> [webpack-dev-server] On Your Network (IPv6): http://[fe80::c7b:e39:b38c:3eef]:8080/
<i> [webpack-dev-server] Content not from webpack is served from 'E:\demo\webpack-App2\public' directory
asset bundleb1ab35c03c69067796e1.js 264 KiB [emitted] [immutable] (name: bundle)
asset index.html 533 bytes [emitted]

直接在浏览器输入：localhost:8080 就能运行脚本
```

然后在webpack.config.js里添加：

```
devServer: {
    static: {
      directory: path.resolve(__dirname, "dist"),
    },
    port: 3000,
    open: true,
    hot: true,
    compress: true,
    historyApiFallback: true,
  },
```

此时如果添加、修改代码运行npm run build 会生成新的打包文件 bundle.js

在webpack.config.js里的output 添加一个属性 

```
clean:true  //再运行npm run build 就不会生成新的打包文件 bundle.js
```

在webpack.config.js里添加 devtool:'source-map'    运行npm run build会成map文件 可以进行断点查错

9.安装转码依赖

```
npm i -D babel-loader @babel/core @babel/preset-env
```

然后在在webpack.config.js里的module对象里的rules数组添加规则：

```
{
        test: /\.js$/,
        exclude: /node_modules/,
        use: {
          loader: "babel-loader",
          options: {
            presets: ["@babel/preset-env"],
          },
        },
      },
```

10.配置图片等规则

# *命名规则（规范）

```
项目命名
      全小写-隔开  my-project-name

    文件命名:小写开头、驼峰命名
      apiUtil.html
      apiUtil.css
      apiUtil.js

    目录命名: 全小写用-分割

    css命名规范
    *小写加-分割
      1)1.位置属性(position, top, right, z-index, display, float等)
        2.大小(width, height, padding, margin)
        3.文字系列(font, line-height, letter-spacing, color- text-align等)
        4.背景(background, border等)
        5.其他(animation, transition等)
      2)属性用简写
      3)去除小数点前面0     .8rem
      4)命名全小写
        命名用-隔开  main-title
        新增前缀  is-withdraw
      2)连字符命名 main-title

    js命名规范
      *变量:小驼峰          maxCount
      *常量:全大写_隔开     MAX_COUNT
      *方法:
        小驼峰、
        前缀应当为动词(get/set/is/has/can/load)
        getData()
      类:大驼峰，首字母大写     Person
      私有属性:前缀为_         _name

    图片业务（可选） +（mod_）图片功能类别（必选）+ 图片模块名称（可选） + 图片精度（可选）
      eg:wx_btn_goodList@2x.png
```

总结：

文件夹、项目名称、文件：用小写字母加-分隔

组件：用驼峰法

变量、方法：小驼峰

常量：全大写_隔开

# *nvm与nrm的安装

安装前的注意事项：

**如果之前安装过node请先卸载之前的node后重启**

- Windows设置 --> 应用--> 找到Node-->点击卸载
- 重启电脑（或者从任务管理器中杀死所有Node相关的进程）
- 寻找以下文件夹并删除他们。根据您安装的版本，这些文件可能存在也可能不存在：
- C:\Program Files (x86)\Nodejs
- C:\Program Files\Nodejs
- C:\Users{User}\AppData\Roaming\npm（或%appdata%\npm）
- C:\Users{User}\AppData\Roaming\npm-cache（或%appdata%\npm-cache）
- 检查%PATH%环境变量，确保没有引用Nodejs和npm的存在
- 重启（重启大法解决90%问题）
- nvm安装位置，看自己决定，但是**安装路径不能有空格**



## 一、NVM

`Nvm` 可以切换 `node` 与 `npm` 版本，在开发不同项目时，可能会用到不同的 `node` 与 `npm` 版本，所以使用 `nvm` 可以方便的在不同 `node` 与 `npm` 版本之间进行切换。

### 写在前面

- 在安装 Nvm 之前，先将之前安装的 node 进行卸载。否则可能会出现无法切换 node 版本的问题
- 将之前安装的全局插件删除掉，否则可能会导致 nvm 命令不起作用。文件目录如下

```
C:\Users\Administrator\AppData\Roaming\npm
C:\Users\Administrator\AppData\Roaming\npm-cache
复制代码
```

### nvm 的安装

下载 nvm 插件，安装地址： [Github： Download nvm-windows （nvm-setup.zip）](https://link.juejin.cn?target=https%3A%2F%2Fgithub.com%2Fcoreybutler%2Fnvm-windows%2Freleases)。

下载完成，解压文件之后，双击进行安装：

- 1. 设置 

     ```
     nvm
     ```

      安装目录，这里的路径可以根据自己的需要进行填写，不要包含中文名

     ![第一步](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/19/169937e724d33e5d~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

- 1. 设置 

     ```
     nodejs
     ```

      各版本安装目录。这个目录是 

     ```
     nvm install node版本
     ```

      时存放 

     ```
     nodejs
     ```

      的目录

     ![第二步](https://p1-jj.byteimg.com/tos-cn-i-t2oaga2asx/gold-user-assets/2019/3/19/169937ebba82ce77~tplv-t2oaga2asx-zoom-in-crop-mark:1304:0:0:0.awebp)

- 1. 安装完成，在命令行输入：`nvm version`，查看到对应的版本号，说明 nvm 安装成功了。

### nvm 常用命令

- `nvm install latest`：   安装最新的 `nodejs` 版本
- `nvm install 11.12.0`：  安装对应的 `nodejs` 版本
- `nvm uninstall 11.12.0`：卸载对应的 `nodejs` 版本
- `nvm list available`：   列出所有可用的 `nodejs` 版本
- `nvm list`：             查看 `nvm` 列出已经安装的 `nodejs` 版本
- `nvm use 11.12.0`：      使用对应的 `nodejs` 版本
- 更多命令在命令行输入 `nvm` 即可查看

### 常见问题

- 提示 nvm 不是内部或外部命令的问题

  - 将之前 npm 安装的全局包删除掉。文件目录如下：

  ```
  C:\Users\Administrator\AppData\Roaming\npm
  C:\Users\Administrator\AppData\Roaming\npm-cache
  复制代码
  ```

- nvm 切换 node 版本无效的问题

  - 卸载原来安装的 node 版本与全局安装的包

- nvm 下载速度慢的问题

  - 在 nvm 安装目录下找到 `settings.txt` 文件，添加下面两行代码：

  ```
  root: D:\DevTools\NVM\nvm
  path: D:\DevTools\NVM\nodejs
  + node_mirror: https://npm.taobao.org/mirrors/node/
  + npm_mirror: https://npm.taobao.org/mirrors/npm/
  复制代码
  ```

------

## 二、NRM

在使用 npm 的过程中，可能插件安装速度比较慢，我们可能会使用淘宝源对插件进行下载安装。或者在公司内部，有一些私有的插件，需要使用公司的源才可以下载。这种情况，我们就需要设置不同的源来进行下载。每次手动设置相对比较麻烦。而 nrm 可以很好的解决这个问题。

### nrm 的安装

```
# 全局安装 nrm
$ npm install nrm -g
复制代码
```

安装完成后，输入命令 `nrm ls`，可以看到默认已经有了 6 个源（带 * 号的为当前使用的源）

```
* npm ---- https://registry.npmjs.org/
  cnpm --- http://r.cnpmjs.org/
  taobao - https://registry.npm.taobao.org/
  nj ----- https://registry.nodejitsu.com/
  npmMirror  https://skimdb.npmjs.com/registry/
  edunpm - http://registry.enpmjs.org/
复制代码
```

输入 `nrm use taobao`，即切换 registry 到 taobao，即可使用淘宝的源进行插件的安装下载了。

### nrm 常用命令

- `nrm ls`              ：查看所有配置好的源以及对应名称
- `nrm add company http://npm.xxx.cn`：添加源，`company` 是名称，可以自行命名，后面是源的 `url` 地址
- `nrm del company`     ：删除源，根据名称 `company` 可以删除对应的源
- `nrm test [registry]` ：测试源的速度，不加对应的 `registry` 名称，测试所有源的速度，添加对应的名称，比如 `company`，就是测试 `company` 对应的源的速度
- `nrm use company`     ：切换源，即可使用 `company` 对应名称的源
- 更多命令在命令行输入 `nrm` 即可查看

FAQ：工具 - nrm ls 不带星（*）并且 nrm current 没有任何输出

执行以下命令，通过源码安装 `nrm`

```
$ npm install Pana/nrm -g 
```

验证：

```
$ nrm ls
* npm ---------- https://registry.npmjs.org/
  yarn --------- https://registry.yarnpkg.com/
  tencent ------ https://mirrors.cloud.tencent.com/npm/
  cnpm --------- https://r.cnpmjs.org/
  taobao ------- https://registry.npmmirror.com/
  npmMirror ---- https://skimdb.npmjs.com/registry/

$ nrm current
You are using npm registry.
```

------



## 三、额外知识点

- 安装 cnpm：`npm install -g cnpm --registry=https://registry.npm.taobao.org`
- 设置 npm 全局包的安装路径（如果不想自己控制路径就不需要做下面这些操作）：
  - 执行命令：`npm config set prefix "D:\DevTools\Nvm\npm-global"`
  - 设置环境变量：将 Path 中： `C:\\Users\\Administrator\\AppData\\Roaming\\npm` 修改为 `D:\\DevTools\\Nvm\\npm-global`
- 查看已经安装的全局包：`npm ls -g --depth=0`
- 手动设置 npm 源
  - `npm config get registry`                                 ： 查看 npm 当前源
  - `npm config set registry https://registry.npm.taobao.org/`：设置 npm 源为淘宝
  - `npm install --registry=https://registry.npm.taobao.org`  ：使用特定源安装所有依赖的包
  - `npm install express --registry=https://registry.npm.taobao.org`：使用特定源安装 express 包

------

## 四、参考链接

- [Windows 下安装 nvm 管理 nodejs 版本](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000007612011)
- [npm源管理器nrm使用教程](https://link.juejin.cn?target=https%3A%2F%2Fsegmentfault.com%2Fa%2F1190000017419993)

作者：暖生
链接：https://juejin.cn/post/6844903799530733582
来源：稀土掘金
著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处

# *HUI框架的问题

1.Ajax接口请求的方式 method: "post",区分大小写 ， 用大写的“POST” 

请求数据的时候会报：Uncaught (in promise) TypeError: Cannot read properties of undefined (reading 'join') 的错误

2.打包npm run build 的时候报：C:\Users\96135\AppData\Roaming\npm-cache\_logs\2022-04-08T01_20_46_605Z-debug.log  

问题：可能是node的版本太高或太低了。

3.单独引入提示弹窗

import { hMessage } from "h_ui"

 hMessage.info({

​     content: "我将在10秒后消失",

​     duration: 10,

​    })

4.hui框架没有像elementui那样的loading加载页面

只能用elementui的loading加载页面

```
import { Loading } from "element-ui"

// loading框设置局部刷新，且所有请求完成后关闭loading框

let loading

function startLoading() {

 loading = Loading.service({

  lock: true,

  text: "加载中...",

  //target: document.querySelector('.app-main')//设置加载动画区域

 })

}

function endLoading() {

 loading.close()

}
```

5.hui框架 用svg矢量图无法显示

# *编程语言的面向问题、面向对象、面向过程的问题

##1.面向问题

###抽象的

*面向问题的*语言这个术语，如果从字面上理解的话，太笼统了，在编程语言的分类中没有用处。就其最一般的含义而言，必须包括任何有助于解决问题的编程语言。因此，当解决科学或数字问题时，Fortran ( *qv* ) 是一种面向问题的语言。Cobol（Common Business-Oriented Language-- *qv*）是面向问题的，即使在它的标题中，也是针对业务问题的。然而，计算机科学文献中公认的用法为面向问题的语言强加了一个比可能包含 Fortran 和 Cobol 的语言更窄的上下文。从这个更受限制的角度来看，面向问题的同义词是面向*应用**程序*或*特殊用途*或*专用应用程序*或*特定领域*。

##2.面向过程

###抽象的

*面向过程的语言*(POL) 是一种人工语言，用于以人类可以理解的形式定义计算机解决问题所需的操作。POL 的高级形式将程序员从用低级语言（如汇编语言和机器语言）表达算法的耗时且通常乏味的苦差事中解放出来（*请参阅*机器和汇编语言编程）。此外，在 POL 中，动作以独立于机器的形式表示，这极大地减轻了将程序从一台计算机移动到另一台计算机的负担（*请参阅*可移植性）。这增加了程序的生命周期和有用性。

##3.面向对象



# *一个完整vue项目的开发过程

## 1.目录结构

1、build：构建脚本目录

　　　　1）build.js  ==> 生产环境构建脚本；``

　　　　2）check-versions.js  ==> 检查npm，node.js版本；

　　　　3）utils.js  ==> 构建相关工具方法；

　　　　4）vue-loader.conf.js  ==> 配置了css加载器以及编译css之后自动添加前缀；

　　　　5）webpack.base.conf.js  ==> webpack基本配置；

　　　　6）webpack.dev.conf.js  ==> webpack开发环境配置；

　　　　7）webpack.prod.conf.js  ==> webpack生产环境配置；

　　2、config：项目配置

　　　　1）dev.env.js  ==> 开发环境变量；

　　　　2）index.js  ==> 项目配置文件；

　　　　3）prod.env.js  ==> 生产环境变量；

　　3、node_modules：npm 加载的项目依赖模块

　　4、src：这里是我们要开发的目录，基本上要做的事情都在这个目录里。里面包含了几个目录及文件：

　　　　1）assets：资源目录，放置一些图片或者公共js、公共css。这里的资源会被webpack构建；

　　　　2）components：组件目录，我们写的组件就放在这个目录里面；

　　　　3）router：前端路由，我们需要配置的路由路径写在index.js里面；

　　　　4）App.vue：根组件；

　　　　5）main.js：入口js文件；

　　5、static：静态资源目录，如图片、字体等。不会被webpack构建

　　6、index.html：首页入口文件，可以添加一些 meta 信息等

　　7、package.json：npm包配置文件，定义了项目的npm脚本，依赖包等信息``

　　8、README.md：项目的说明文档，markdown 格式

　　9、.xxxx文件：这些是一些配置文件，包括语法配置，git配置等



##2.代码的格式化和lint代码检查问题

### vscode插件

首先vscode需要装一些vscode插件

ESLint、Vetur、Prettier-Code formatter、GitLens-Git supercharged

### 配置settings.json

打开settings.json，贴上配置，注意自己原有的vscode主题和字体等不要替换掉

打开方式

#### 方式一:

1)文件 ------.>【首选项】---------->【设置】

2）搜索emmet.include;

3）在settings.json下的【工作区设置】中添加

#### 方式二:

Ctrl + P 搜索settings.json

### 贴上如下配置

```
{
  "window.zoomLevel": 0,
  "diffEditor.ignoreTrimWhitespace": false,
  "workbench.colorTheme": "One Monokai",
  "editor.fontSize": 14,
  "workbench.editor.enablePreview": true, //预览模式关闭
  "editor.formatOnSave": true, // #每次保存的时候自动格式化
  // 自动修复
  "editor.codeActionsOnSave": {
    "source.fixAll.eslint": true,
  },
  "eslint.enable": true, //是否开启vscode的eslint
  // vscode默认启用了根据文件类型自动设置tabsize的选项
  "editor.detectIndentation": false,
  // 重新设定tabsize
  "editor.tabSize": 2,
  //  #去掉代码结尾的分号 
  "prettier.semi": false,
  //  #使用单引号替代双引号 
  "prettier.singleQuote": true,  
  //  #让prettier使用eslint的代码格式进行校验 
  "prettier.eslintIntegration": true,
  "javascript.preferences.quoteStyle": "double",
  "typescript.preferences.quoteStyle": "double",
  //  #让函数(名)和后面的括号之间加个空格
  "javascript.format.insertSpaceBeforeFunctionParenthesis": true,
  // 配置 ESLint 检查的文件类型
  "eslint.validate": [
    "javascript",
    "vue",
    "html"
  ],
  "eslint.options": { //指定vscode的eslint所处理的文件的后缀
    "extensions": [
      ".js",
      ".vue",
      ".ts",
      ".tsx"
    ]
  }, 
  "git.enableSmartCommit": true,
  "editor.quickSuggestions": {
    "strings": true
  },
  //一定要在vutur.defaultFormatterOptions参数中设置，单独修改prettier扩展的设置是无法解决这个问题的，因为perttier默认忽略了vue文件（事实上从忽略列表移除vue也不能解决这个问题）
  "vetur.format.defaultFormatterOptions": {
    "prettier": {
      "semi": false, // 格式化不加分号
      "singleQuote": true, // 格式化以单引号为主
    },
    "js-beautify-html": {
      // force-aligned | force-expand-multiline vue html代码格式化
      "wrap_attributes": "force-aligned",//"auto","force-expand-multiline"
      "wrap_line_length": 200,
      "wrap_width_line": false,
      "semi": false,
      "singleQuote": true,
    },
    "prettyhtml": {
      "printWidth": 100,
      "singleQuote": false,
      "wrapAttributes": false,
      "sortAttributes": true
    },
  },
  "vetur.format.defaultFormatter.html": "js-beautify-html",
  "vetur.format.defaultFormatter.js": "prettier",
  "[vue]": {
    "editor.defaultFormatter": "octref.vetur"
  },
  "javascript.updateImportsOnFileMove.enabled": "never",
  "javascript.implicitProjectConfig.experimentalDecorators": true,
  "workbench.editor.showTabs": true,
  "gitlens.advanced.messages": {
        "suppressCommitHasNoPreviousCommitWarning": false,
        "suppressCommitNotFoundWarning": false,
        "suppressFileNotUnderSourceControlWarning": false,
        "suppressGitVersionWarning": false,
        "suppressLineUncommittedWarning": false,
        "suppressNoRepositoryWarning": false,
        "suppressResultsExplorerNotice": false,
        "suppressShowKeyBindingsNotice": true,
        "suppressUpdateNotice": false,
        "suppressWelcomeNotice": true
    },
    "gitlens.keymap": "alternate",
    "git.enableSmartCommit": true,
    "gitlens.historyExplorer.enabled": true,
    "gitlens.views.fileHistory.enabled": true,
    "gitlens.views.lineHistory.enabled": true,
}
```



##2.屏幕的自适应

2-1.侧边栏可以根据屏幕的尺寸进行收缩隐藏

# *使用treer工具，生成目录书结构

treer是一个目录树生成工具

npm链接：[https://www.npmjs.com/package/treer](https://links.jianshu.com/go?to=https%3A%2F%2Fwww.npmjs.com%2Fpackage%2Ftreer)
安装：

```
npm install treer -g
```

查看版本：

```
treer --version
```

使用方法：

```
treer //查看目录树
treer -d <指定路径>//查看指定路径的目录树
treer -e <导出路径>//导出当前目录的目录树到特定路径下文件
treer -i "/^regex$/"//忽略目录或文件  treer -i "/node_modules/" 
```

# *闭包

闭包就是就是必须要调用函数才能保存过程值，就像let和const一样，工场函数就是这个道理，因为是以传入参数然后调用再返回一个函数的方式，第一次调用函数的时候就已经保存了这个过程值而不是最后的值。



#####javascript的闭包怎么理解？一般怎么用？哪些场景会用到？

JavaScript的闭包是指在一个函数内部定义的函数，这个函数可以访问外部函数的变量、参数和函数。在JavaScript中，函数和变量具有作用域，变量在函数外部是不可访问的，但是函数内部可以定义函数，这个函数可以访问外部函数的变量，这种函数就是闭包。

闭包的一般用法是用来创建私有变量和方法。通过在函数内部定义变量，然后在函数内部再定义一个函数，这个函数可以访问函数内部的变量，然后将这个函数返回，这样就可以通过返回的函数来访问函数内部的变量，形成一个闭合的作用域。这种方式可以将变量和方法封装在一个作用域内，避免了变量名和方法名的冲突。这种方式可以实现模块化编程，并且可以防止外部代码的误操作。

闭包可以用在很多场景中，例如在事件处理函数中，可以将变量保存在闭包中，这样在事件处理函数执行时，就可以访问到这些变量。在回调函数中，闭包可以将一些参数保存下来，以便在回调函数执行时使用。在面向对象编程中，闭包可以模拟私有变量和方法，实现类的封装。在异步编程中，闭包可以保存一些状态，以便在异步操作完成后使用。总之，闭包是JavaScript中非常重要和常用的特性。



# *js

####比较两个数组对象中相同的项

```js
let intersection = a.filter(v => b.includes(v))
let difference = a.concat(b).filter(v => !a.includes(v) || !b.includes(v))
```

####链判断运算符

```javascript
const firstName = message?.body?.user?.firstName || 'default';
const fooValue = myForm.querySelector('input[name=foo]')?.value
```

上面代码使用了`?.`运算符，直接在链式调用的时候判断，左侧的对象是否为`null`或`undefined`。如果是的，就不再往下运算，而是返回`undefined`。

下面是判断对象方法是否存在，如果存在就立即执行的例子。

```javascript
iterator.return?.()
```

上面代码中，`iterator.return`如果有定义，就会调用该方法，否则`iterator.return`直接返回`undefined`，不再执行`?.`后面的部分。

对于那些可能没有实现的方法，这个运算符尤其有用。

```javascript
if (myForm.checkValidity?.() === false) {
  // 表单校验失败
  return;
}
```

上面代码中，老式浏览器的表单对象可能没有`checkValidity()`这个方法，这时`?.`运算符就会返回`undefined`，判断语句就变成了`undefined === false`，所以就会跳过下面的代码。

链判断运算符`?.`有三种写法。

- `obj?.prop` // 对象属性是否存在

- `obj?.[expr]` // 同上

- `func?.(...args)` // 函数或对象方法是否存在

  ------

  以下写法是禁止的，会报错。

  ```javascript
  // 构造函数
  new a?.()
  new a?.b()
  
  // 链判断运算符的右侧有模板字符串
  a?.`{b}`
  a?.b`{c}`
  
  // 链判断运算符的左侧是 super
  super?.()
  super?.foo
  
  // 链运算符用于赋值运算符左侧
  a?.b = c
  ```

  （4）右侧不得为十进制数值

  为了保证兼容以前的代码，允许`foo?.3:0`被解析成`foo ? .3 : 0`，因此规定如果`?.`后面紧跟一个十进制数字，那么`?.`不再被看成是一个完整的运算符，而会按照三元运算符进行处理，也就是说，那个小数点会归属于后面的十进制数字，形成一个小数

#### Null判断运算符

读取对象属性的时候，如果某个属性的值是`null`或`undefined`，有时候需要为它们指定默认值。常见做法是通过`||`运算符指定默认值。

```javascript
const headerText = response.settings.headerText || 'Hello, world!';
const animationDuration = response.settings.animationDuration || 300;
const showSplashScreen = response.settings.showSplashScreen || true;
```

上面的三行代码都通过`||`运算符指定默认值，但是这样写是错的。<span style='color:red'>开发者的原意是，只要属性的值为`null`或`undefined`，默认值就会生效，但是属性的值如果为空字符串或`false`或`0`，默认值也会生效。</span>

为了避免这种情况，[ES2020](https://github.com/tc39/proposal-nullish-coalescing) 引入了一个新的 Null 判断运算符`??`。它的行为类似`||`，但是只有运算符左侧的值为`null`或`undefined`时，才会返回右侧的值。

```javascript
const headerText = response.settings.headerText ?? 'Hello, world!';
const animationDuration = response.settings.animationDuration ?? 300;
const showSplashScreen = response.settings.showSplashScreen ?? true;
```

上面代码中，默认值只有在左侧属性值为`null`或`undefined`时，才会生效。

这个运算符的一个目的，就是跟链判断运算符`?.`配合使用，为`null`或`undefined`的值设置默认值。

```javascript
const animationDuration = response.settings?.animationDuration ?? 300;
```

上面代码中，如果`response.settings`是`null`或`undefined`，或者`response.settings.animationDuration`是`null`或`undefined`，就会返回默认值300。也就是说，这一行代码包括了两级属性的判断。

这个运算符很适合判断函数参数是否赋值。

```javascript
function Component(props) {
  const enable = props.enabled ?? true;
  // …
}
```

上面代码判断`props`参数的`enabled`属性是否赋值，基本等同于下面的写法。

```javascript
function Component(props) {
  const {
    enabled: enable = true,
  } = props;
  // …
}
```

`??`本质上是逻辑运算，它与其他两个逻辑运算符`&&`和`||`有一个优先级问题，它们之间的优先级到底孰高孰低。优先级的不同，往往会导致逻辑运算的结果不同。

现在的规则是，如果多个逻辑运算符一起使用，必须用括号表明优先级，否则会报错。

```javascript
// 报错
lhs && middle ?? rhs
lhs ?? middle && rhs
lhs || middle ?? rhs
lhs ?? middle || rhs
```

上面四个表达式都会报错，必须加入表明优先级的括号。

```javascript
(lhs && middle) ?? rhs;
lhs && (middle ?? rhs);

(lhs ?? middle) && rhs;
lhs ?? (middle && rhs);

(lhs || middle) ?? rhs;
lhs || (middle ?? rhs);

(lhs ?? middle) || rhs;
lhs ?? (middle || rhs);
```

#### 逻辑赋值运算符

ES2021 引入了三个新的[逻辑赋值运算符](https://github.com/tc39/proposal-logical-assignment)（logical assignment operators），将逻辑运算符与赋值运算符进行结合。

```javascript
// 或赋值运算符
x ||= y
// 等同于
x || (x = y)

// 与赋值运算符
x &&= y
// 等同于
x && (x = y)

// Null 赋值运算符
x ??= y
// 等同于
x ?? (x = y)
```

这三个运算符`||=`、`&&=`、`??=`相当于先进行逻辑运算，然后根据运算结果，再视情况进行赋值运算。

它们的一个用途是，为变量或属性设置默认值。

```javascript
// 老的写法
user.id = user.id || 1;

// 新的写法
user.id ||= 1;
```

上面示例中，`user.id`属性如果不存在，则设为`1`，新的写法比老的写法更紧凑一些。

下面是另一个例子。

```javascript
function example(opts) {
  opts.foo = opts.foo ?? 'bar';
  opts.baz ?? (opts.baz = 'qux');
}
```

上面示例中，参数对象`opts`如果不存在属性`foo`和属性`baz`，则为这两个属性设置默认值。有了“Null 赋值运算符”以后，就可以统一写成下面这样。

```javascript
function example(opts) {
  opts.foo ??= 'bar';
  opts.baz ??= 'qux';
}
```

## Promise.try() 

<span style='color:red'>实际开发中，经常遇到一种情况：不知道或者不想区分，函数`f`是同步函数还是异步操作，但是想用 Promise 来处理它。</span>因为这样就可以不管`f`是否包含异步操作，都用`then`方法指定下一步流程，用`catch`方法处理`f`抛出的错误。一般就会采用下面的写法。

```javascript
Promise.resolve().then(f)
```

上面的写法有一个缺点，就是如果`f`是同步函数，那么它会在本轮事件循环的末尾执行。

```javascript
const f = () => console.log('now');
Promise.resolve().then(f);
console.log('next');
// next
// now
```

上面代码中，函数`f`是同步的，但是用 Promise 包装了以后，就变成异步执行了。

那么有没有一种方法，让同步函数同步执行，异步函数异步执行，并且让它们具有统一的 API 呢？回答是可以的，并且还有两种写法。第一种写法是用`async`函数来写。

```javascript
const f = () => console.log('now');
(async () => f())();
console.log('next');
// now
// next
```

上面代码中，第二行是一个立即执行的匿名函数，会立即执行里面的`async`函数，因此如果`f`是同步的，就会得到同步的结果；如果`f`是异步的，就可以用`then`指定下一步，就像下面的写法。

```javascript
(async () => f())()
.then(...)
```

需要注意的是，`async () => f()`会吃掉`f()`抛出的错误。所以，如果想捕获错误，要使用`promise.catch`方法。

```javascript
(async () => f())()
.then(...)
.catch(...)
```

第二种写法是使用`new Promise()`。

```javascript
const f = () => console.log('now');
(
  () => new Promise(
    resolve => resolve(f())
  )
)();
console.log('next');
// now
// next
```

上面代码也是使用立即执行的匿名函数，执行`new Promise()`。这种情况下，同步函数也是同步执行的。

鉴于这是一个很常见的需求，所以现在有一个[提案](https://github.com/ljharb/proposal-promise-try)，提供`Promise.try`方法替代上面的写法。

```javascript
const f = () => console.log('now');
Promise.try(f);
console.log('next');
// now
// next
```

事实上，`Promise.try`存在已久，Promise 库[`Bluebird`](http://bluebirdjs.com/docs/api/promise.try.html)、[`Q`](https://github.com/kriskowal/q/wiki/API-Reference#promisefcallargs)和[`when`](https://github.com/cujojs/when/blob/master/docs/api.md#whentry)，早就提供了这个方法。

由于`Promise.try`为所有操作提供了统一的处理机制，所以如果想用`then`方法管理流程，最好都用`Promise.try`包装一下。这样有[许多好处](http://cryto.net/~joepie91/blog/2016/05/11/what-is-promise-try-and-why-does-it-matter/)，其中一点就是可以更好地管理异常。

```javascript
function getUsername(userId) {
  return database.users.get({id: userId})
  .then(function(user) {
    return user.name;
  });
}
```

上面代码中，`database.users.get()`返回一个 Promise 对象，如果抛出异步错误，可以用`catch`方法捕获，就像下面这样写。

```javascript
database.users.get({id: userId})
.then(...)
.catch(...)
```

但是`database.users.get()`可能还会抛出同步错误（比如数据库连接错误，具体要看实现方法），这时你就不得不用`try...catch`去捕获。

```javascript
try {
  database.users.get({id: userId})
  .then(...)
  .catch(...)
} catch (e) {
  // ...
}
```

上面这样的写法就很笨拙了，这时就可以统一用`promise.catch()`捕获所有同步和异步的错误。

```javascript
Promise.try(() => database.users.get({id: userId}))
  .then(...)
  .catch(...)
```

事实上，`Promise.try`就是模拟`try`代码块，就像`promise.catch`模拟的是`catch`代码块。
